0 ARG : 
[ ] -> 1

1 ARG : 
[ arg ] -> arg != 0

2 ARG :
[ ! arg ] -> arg == 0
[ unary_op arg ] -> vrai si unary vrai

3 ARG :
[ ! unary_op arg ]
[ arg binary_op arg ]
[ ( arg ) ]
sinon 1

4 ARG :
[ ! arg binary_op arg ]
[ ( unary_op arg ) ]






[ \( -d mandatory -a -d bonus \) -o -f minishell ]
IN_PAR = 0;
( -> IN_PAR = 1
-d mandatory -> TRUE
-a TRUE donc CONTINUE
-d bonus -> FALSE
) -> IN_PAR = 0
-o FALSE donc CONTINUE
-f minishell -> TRUE
return TRUE

[ \( -d bonus -a -d mandatory \) -o -f minishell ]
IN_PAR = 0;
( -> IN_PAR = 1
-d bonus -> FALSE
-a FALSE donc BREAK : avance jusque fin
) -> IN_PAR = 0
-o FALSE donc CONTINUE
-f minishell -> TRUE
return TRUE

[ \( -d bonus -o \( -d mandatory -a -f minishell \) \) -a \( -f minishell -a -t 1 \) ]
IN_PAR = 0;
( -> IN_PAR = 1
-d bonus -> FALSE
-o FALSE donc CONTINUE
( -> IN_PAR = 2
-d mandatory -> TRUE
-a TRUE donc CONTINUE
-f minishell -> TRUE
) -> IN_PAR = 1
) -> IN_PAR = 0
-a TRUE donc CONTINUE
( -> IN_PAR = 1
-f minishell -> TRUE
-a TRUE donc CONTINUE
-t 1 -> TRUE
) -> IN_PAR = 0
return TRUE

( IN_PAR++
) IN_PAR--
TEST -> compris entre -a, -o, (, ), [, ], test
-o -a -> regarder dernière return value : si faux, avancer jusqu'à closing parenthesis ou fin

ERREURS:
Too many arguments

compte total total (jusque fin ou jusque parenthese)
si 0 : alors 1
si 1 : alors que fichier
si 2 : unitaire
si 3 : binaire ou unitaire nég + gérer 'et'
si 4 : binaire nég + gérer 'et'

si 5 ou plus :
DECOUPAGE : ! -> ( ) -> -a et -o

 0  -> ARG1 != '!' et de '('
lol -a mdr \( -f minishell \)

 0  ->  0  -> 
lol -a mdr -a \( -f minishell \)
